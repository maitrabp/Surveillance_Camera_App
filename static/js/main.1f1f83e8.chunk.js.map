{"version":3,"sources":["RecordReducer.js","context/RecordState.js","Recordings.js","DrawingUtilities/canvas.js","DrawingUtilities/renderpredictions.js","Home.js","App.js","serviceWorker.js","index.js"],"names":["state","action","type","videos","push","payload","initialState","RecordContext","createContext","RecordProvider","children","useReducer","RecordReducer","dispatch","Provider","value","addVideo","Recordings","useContext","console","log","className","style","width","length","map","video","key","title","controls","src","href","getRetinaContext","canvas","ctx","getContext","scale","window","devicePixelRatio","height","setWidth","w","setHeight","h","clearAll","clearRect","x","y","setFont","font","size","parseInt","retinaFont","replace","setTextBaseLine","textBaseline","setStrokeStyle","strokeStyle","setLineWidth","lineWidth","strokeRect","setFillStyle","fillStyle","measureText","text","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillRect","fillText","getLabelText","prediction","scoreText","score","toFixed","class","renderPredictions","predictions","textHeight","forEach","bbox","predictionText","Math","round","textWidth","border","xPadding","yPadding","Home","props","videoElement","useRef","canvasElement","startButtonElement","stopButtonElement","modelRef","lastDetectionRef","recorderRef","shouldRecordRef","isRecordingRef","detectFrame","a","current","stopRecording","detect","foundperson","wantedWidth","offsetWidth","wantedHeight","offsetHeight","videoWidth","videoHeight","scaleX","scaleY","max","xOffset","yOffset","i","JSON","stringify","offsetPredictions","startRecording","filter","Boolean","slice","requestAnimationFrame","changeStreamStatus","MediaRecorder","stream","ondataavailable","e","Date","URL","createObjectURL","data","start","stop","useEffect","setAttribute","document","querySelector","visibility","navigator","mediaDevices","getUserMedia","audio","ideal","srcObject","cocoSSD","model","removeAttribute","display","error","alert","prepare","maxHeight","id","objectFit","autoPlay","playsInline","muted","ref","role","onClick","App","useState","streamRef","setStreamStatus","streamCheck","basename","data-toggle","justifyContent","label","flexDirection","to","fontSize","marginRight","exact","path","render","component","location","hostname","match","ReactDOM","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.1f1f83e8.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nexport default (state, action) => {\r\n    switch (action.type) {\r\n      case \"ADD_VIDEO\":\r\n        state.videos.push({\r\n            ...action.payload,\r\n        })\r\n        return {\r\n          ...state,\r\n          videos: [...state.videos],\r\n        }\r\n      default:\r\n        return {\r\n            ...state,\r\n          };\r\n    }\r\n  };","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { createContext, useReducer } from \"react\";\r\nimport RecordReducer from \"../RecordReducer\";\r\n\r\nconst initialState = {\r\n    videos: [\r\n    ],\r\n  };\r\n  \r\n\r\nexport const RecordContext = createContext(initialState);\r\nexport const RecordProvider = ({children}) => {\r\n  const [state, dispatch] = useReducer(RecordReducer, initialState)\r\n  function addVideo(videos) {\r\n    dispatch({\r\n      type: \"ADD_VIDEO\",\r\n      payload: videos\r\n    });\r\n  }\r\n\r\n  return (\r\n    <RecordContext.Provider\r\n      value={{\r\n        videos: state.videos,\r\n        addVideo,\r\n      }}\r\n    >\r\n      {children}\r\n    </RecordContext.Provider>\r\n  );\r\n};","import React, {useContext} from 'react'\r\nimport {RecordContext} from './context/RecordState'\r\nfunction Recordings() {\r\n    const {videos} = useContext(RecordContext);\r\n    console.log(videos)\r\n    return (\r\n        <div className=\"row p-3 h-70\">\r\n          <h5 className=\"display-6 d-flex justify-content-center\" style={{width:\"100%\"}}>Records:</h5>\r\n          <hr/>\r\n          {!videos.length\r\n            ? null\r\n            : videos.map((video) => {\r\n              return (\r\n                <div className=\"card mt-3 w-100\" key={video.title}>\r\n                  <div className=\"card-body\">\r\n                    <h6 className=\"card-title\">{video.title}</h6>\r\n                    <div className=\"embed-responsive embed-responsive-21by9 border border-white\">\r\n                      <video className= \"embed-responsive-item\" controls src={video.href}></video>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Recordings\r\n","export const getRetinaContext = (canvas) => {\r\n    const ctx = canvas.getContext('2d')\r\n    const scale = window.devicePixelRatio\r\n    let width = canvas.width / scale\r\n    let height = canvas.height / scale\r\n    return {\r\n      //Set width of the canvas\r\n      setWidth: (w) => {\r\n        width = w\r\n        canvas.style.width = w + 'px'\r\n        canvas.width = w * scale\r\n      },\r\n      //Set height of the canvas\r\n      setHeight: (h) => {\r\n        height = h\r\n        canvas.style.height = h + 'px'\r\n        canvas.height = h * scale\r\n      },\r\n      //Default width\r\n      width: width,\r\n      height: height,\r\n      //clears all on canvas (same height & width as canvas)\r\n      clearAll: () => {\r\n        return ctx.clearRect(0, 0, width * scale, height * scale)\r\n      },\r\n      //clears recttangle on canvas at x,y\r\n      clearRect: (x, y, width, height) => {\r\n        return ctx.clearRect(x * scale, y * scale, width * scale, height * scale)\r\n      },\r\n      //font of the label\r\n      setFont: (font) => {\r\n        const size = parseInt(font, 10) * scale\r\n        const retinaFont = font.replace(/^\\d+px/, size + 'px')\r\n        ctx.font = retinaFont\r\n      },\r\n      //styling\r\n      setTextBaseLine: (textBaseline) => {\r\n        ctx.textBaseline = textBaseline\r\n      },\r\n      setStrokeStyle: (strokeStyle) => {\r\n        ctx.strokeStyle = strokeStyle\r\n      },\r\n      setLineWidth: (lineWidth) => {\r\n        ctx.lineWidth = lineWidth * scale\r\n      },\r\n      strokeRect: (x, y, width, height) => {\r\n        return ctx.strokeRect(x * scale, y * scale, width * scale, height * scale)\r\n      },\r\n      setFillStyle: (fillStyle) => {\r\n        ctx.fillStyle = fillStyle\r\n      },\r\n      measureText: (text) => {\r\n        const metrics = ctx.measureText(text)\r\n        return {\r\n          width: metrics.width / scale,\r\n          actualBoundingBoxLeft: metrics.actualBoundingBoxLeft / scale,\r\n          actualBoundingBoxRight: metrics.actualBoundingBoxRight / scale,\r\n          actualBoundingBoxAscent: metrics.actualBoundingBoxAscent / scale,\r\n          actualBoundingBoxDescent: metrics.actualBoundingBoxDescent / scale,\r\n        }\r\n      },\r\n      fillRect: (x, y, width, height) => {\r\n        return ctx.fillRect(x * scale, y * scale, width * scale, height * scale)\r\n      },\r\n      fillText: (text, x, y) => {\r\n        return ctx.fillText(text, x * scale, y * scale)\r\n      },\r\n    }\r\n  }","const getLabelText = (prediction) => {\r\n    const scoreText = (prediction.score * 100).toFixed(1)\r\n    return `${prediction.class} ${scoreText}%`\r\n  }\r\n  \r\n  export const renderPredictions = (ctx, predictions) => {\r\n    // Font options.\r\n    const font = `${16}px 'ibm-plex-sans', Helvetica Neue, Arial, sans-serif`\r\n    ctx.setFont(font)\r\n    ctx.setTextBaseLine('top')\r\n    const border = 4\r\n    const xPadding = 16\r\n    const yPadding = 8\r\n    const offset = 6\r\n    const textHeight = parseInt(font, 10) // base 10\r\n  \r\n    predictions.forEach((prediction) => {\r\n      const x = prediction.bbox[0]\r\n      const y = prediction.bbox[1]\r\n      const width = prediction.bbox[2]\r\n      const height = prediction.bbox[3]\r\n  \r\n      const predictionText = getLabelText(prediction)\r\n  \r\n      // Draw the bounding box.\r\n      ctx.setStrokeStyle('#0062ff')\r\n      ctx.setLineWidth(border)\r\n  \r\n      ctx.strokeRect(\r\n        Math.round(x),\r\n        Math.round(y),\r\n        Math.round(width),\r\n        Math.round(height)\r\n      )\r\n      // Draw the label background.\r\n      ctx.setFillStyle('#0062ff')\r\n      const textWidth = ctx.measureText(predictionText).width\r\n      ctx.fillRect(\r\n        Math.round(x - border / 2),\r\n        Math.round(y - (textHeight + yPadding) - offset),\r\n        Math.round(textWidth + xPadding),\r\n        Math.round(textHeight + yPadding)\r\n      )\r\n    })\r\n  \r\n    predictions.forEach((prediction) => {\r\n      const x = prediction.bbox[0]\r\n      const y = prediction.bbox[1]\r\n  \r\n      const predictionText = getLabelText(prediction)\r\n      // Draw the text last to ensure it's on top.\r\n      ctx.setFillStyle('#ffffff')\r\n      ctx.fillText(\r\n        predictionText,\r\n        Math.round(x - border / 2 + xPadding / 2),\r\n        Math.round(y - (textHeight + yPadding) - offset + yPadding / 2)\r\n      )\r\n    })\r\n  }","import React, { useRef, useEffect, useContext } from \"react\";\r\nimport { RecordContext } from \"./context/RecordState\";\r\nimport * as cocoSSD from \"@tensorflow-models/coco-ssd\";\r\nimport \"@tensorflow/tfjs\";\r\nimport \"./App.css\";\r\nimport { getRetinaContext } from './DrawingUtilities/canvas'\r\nimport { renderPredictions } from \"./DrawingUtilities/renderpredictions\";\r\nfunction Home(props) {\r\n    const videoElement = useRef(null);\r\n    const canvasElement = useRef(null);\r\n    const startButtonElement = useRef(null);\r\n    const stopButtonElement = useRef(null);\r\n    const modelRef = useRef(null);\r\n    const lastDetectionRef = useRef([]);\r\n    const recorderRef = useRef(null);\r\n    const shouldRecordRef = useRef(false);\r\n    const isRecordingRef = useRef(false);\r\n    const {addVideo} = useContext(RecordContext);\r\n    //when the page renders, you wanna do this\r\n    useEffect(() => { \r\n      async function prepare() {\r\n        startButtonElement.current.setAttribute(\"disabled\", true);\r\n        stopButtonElement.current.setAttribute(\"disabled\", true);\r\n        //Loading screen until the stream starts\r\n        document.querySelector( \r\n          \"body\").style.visibility = \"hidden\"; \r\n        document.querySelector( \r\n          \"#loader\").style.visibility = \"visible\"; \r\n\r\n        //If camera detected, then\r\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n          //get the cam, make sure audio and video are enabled\r\n          try {\r\n            //on iphones it defaults to front camera, to change it google\r\n            const stream = await navigator.mediaDevices.getUserMedia({\r\n              audio: true,\r\n              video: {\r\n                width: { ideal: 4096 },\r\n                height: { ideal: 2160 } \r\n              }\r\n            });\r\n            //put the stream on our window stream\r\n            window.stream = stream;\r\n            videoElement.current.srcObject = stream;\r\n  \r\n            //TODO LOAD THE MODEL FROM COCO & assign\r\n            const model = await cocoSSD.load();\r\n            modelRef.current = model;\r\n  \r\n            //starts so not disabeld\r\n            startButtonElement.current.removeAttribute(\"disabled\");\r\n\r\n            //Show screen once the start button is displayed\r\n            document.querySelector( \r\n              \"#loader\").style.display = \"none\"; \r\n            document.querySelector( \r\n              \"body\").style.visibility = \"visible\"; \r\n\r\n          } catch (error) {\r\n            console.error(error);\r\n          }\r\n        } else {\r\n            //Show screen once the start button is displayed\r\n            document.querySelector( \r\n              \"#loader\").style.display = \"none\"; \r\n            document.querySelector( \r\n              \"body\").style.visibility = \"visible\"; \r\n            window.alert(\"No Camera Detected. You must have a camera to run this app\");\r\n        }\r\n      }\r\n      prepare();\r\n    }, []);\r\n    async function detectFrame() {\r\n      //when should recordref value changes to false, we wanna stop recording (because frame runs recursively)\r\n      if (!shouldRecordRef.current) {\r\n        stopRecording();\r\n        return;\r\n      }\r\n  \r\n      //Predictions will be of the objects detected within our frame\r\n      const predictions = await modelRef.current.detect(videoElement.current);\r\n      let foundperson = false;\r\n      \r\n      const wantedWidth = videoElement.current.offsetWidth\r\n      const wantedHeight = videoElement.current.offsetHeight\r\n      const videoWidth = videoElement.current.videoWidth\r\n      const videoHeight = videoElement.current.videoHeight\r\n\r\n      const scaleX = wantedWidth / videoWidth\r\n      const scaleY = wantedHeight / videoHeight\r\n\r\n      let scale\r\n      scale = Math.max(scaleX, scaleY)\r\n\r\n      const xOffset = (wantedWidth - videoWidth * scale) / 2\r\n      const yOffset = (wantedHeight - videoHeight * scale) / 2\r\n\r\n      const ctx = getRetinaContext(canvasElement.current)\r\n      ctx.setWidth(wantedWidth)\r\n      ctx.setHeight(wantedHeight)\r\n      ctx.clearAll()\r\n\r\n      for (let i = 0; i < predictions.length; i++) {\r\n        if (predictions[i].class == \"person\") {\r\n          console.log(JSON.stringify(predictions[i]));\r\n          foundperson = true;\r\n        }\r\n      }\r\n      // Update predictions to match canvas.\r\n      const offsetPredictions = predictions.map((prediction) => {\r\n        if(prediction.class == \"person\") {\r\n          let x = prediction.bbox[0] * scale + xOffset\r\n          const y = prediction.bbox[1] * scale + yOffset\r\n          const width = prediction.bbox[2] * scale\r\n          const height = prediction.bbox[3] * scale\r\n\r\n          return { ...prediction, bbox: [x, y, width, height] }\r\n        }\r\n        else {\r\n          return{...[], bbox: [0, 0, 0, 0]}\r\n        }\r\n      })\r\n      const renderFunction = renderPredictions\r\n\r\n      renderFunction(ctx, offsetPredictions)\r\n  \r\n      if (foundperson) {\r\n        startRecording();\r\n        lastDetectionRef.current.push(true);\r\n      } else if (lastDetectionRef.current.filter(Boolean).length) { //cont.. recording because there was one true before, maybe we lost couple frame so we do not detect a person.\r\n        startRecording();\r\n        lastDetectionRef.current.push(false)\r\n      }\r\n      else { //no objs within last ten frames stop recording\r\n        stopRecording();\r\n      }\r\n  \r\n      //leave ten most recent frames\r\n      lastDetectionRef.current = lastDetectionRef.current.slice(\r\n        Math.max(lastDetectionRef.current.length - 10, 0)\r\n      )\r\n      requestAnimationFrame(() => {\r\n        detectFrame();\r\n      });\r\n    }\r\n    function startRecording() {\r\n      //If already started recording, then get out of this func\r\n      if (isRecordingRef.current) {\r\n        return;\r\n      }\r\n      //else start\r\n      isRecordingRef.current = true;\r\n\r\n      console.log(\"start recording\");\r\n      props.changeStreamStatus(true); \r\n      recorderRef.current = new MediaRecorder(window.stream);\r\n  \r\n      recorderRef.current.ondataavailable = function (e) {\r\n        const title = new Date() + \"\";\r\n        const href = URL.createObjectURL(e.data);\r\n        const videos = {href: href, title: title};\r\n        //add video to the context, use it from the context in other components\r\n        addVideo(videos);\r\n      };\r\n      recorderRef.current.start();\r\n    };\r\n  \r\n    function stopRecording() {\r\n      //If already stopped recording, then get out of this func\r\n      if (!isRecordingRef.current) {\r\n        return;\r\n      }\r\n      //else stop\r\n      isRecordingRef.current = false;\r\n      props.changeStreamStatus(false); \r\n      recorderRef.current.stop();\r\n      console.log(\"Stopped recording\");\r\n      lastDetectionRef.current = []\r\n    }\r\n    return (\r\n    <div className=\"p-3\" style={{maxHeight:\"50%\"}}>\r\n      <h6 className=\"d-flex justify-content-center text-info\" style={{width:\"100%\"}}><b>Surveillance Camera</b></h6>\r\n      <p className=\"d-flex justify-content-center\" style={{width:\"100%\"}}>Note: Make sure the lighting is good before you start recording. Once you press start, the application keeps track of movement and stores them as video feeds.</p>\r\n        <div id=\"videoOutline\" className=\"embed-responsive embed-responsive-21by9 border border-white\">\r\n          <video className= \"embed-responsive-item\" style={{objectFit:\"cover\"}}autoPlay playsInline muted ref={videoElement} />\r\n          <canvas className= \"embed-responsive-item\" ref={canvasElement} />\r\n        </div>\r\n        <div className = \"d-flex justify-content-center border border-white\">\r\n          <div className=\"btn-toolbar\" role=\"toolbar\">\r\n            <div className=\"btn-group m-1\" role=\"group\">\r\n              <button\r\n                className=\"btn btn-outline-white btn-block\"\r\n                onClick={() => {\r\n                  shouldRecordRef.current = true;\r\n                  stopButtonElement.current.removeAttribute(\"disabled\");\r\n                  startButtonElement.current.setAttribute(\"disabled\", true);\r\n                  detectFrame();\r\n                }}\r\n                ref={startButtonElement}\r\n              >\r\n                Start\r\n              </button>\r\n            </div>\r\n            <div className=\"btn-group m-1\" role=\"group\">\r\n              <button\r\n                className=\"btn btn-outline-white btn-block\"\r\n                onClick={() => {\r\n                  shouldRecordRef.current = false;\r\n                  startButtonElement.current.removeAttribute(\"disabled\");\r\n                  stopButtonElement.current.setAttribute(\"disabled\", true);\r\n                  stopRecording();\r\n                }}\r\n                ref={stopButtonElement}\r\n              >\r\n                Stop\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    )\r\n}\r\n\r\nexport default Home\r\n","import React, {useContext, useState} from \"react\";\nimport {HashRouter, Switch, Route, Link, Redirect} from \"react-router-dom\";\nimport { RecordContext } from \"./context/RecordState\";\nimport Recordings from \"./Recordings\";\nimport Home from \"./Home\"\nimport PersonalVideoIcon from '@material-ui/icons/PersonalVideo';\nimport SlideshowIcon from '@material-ui/icons/Slideshow';\nimport {RecordProvider} from \"./context/RecordState\";\nimport \"./App.css\";\n\nconst App = () => {\n\n/*   const subIncrementStyles = {\n    borderRadius: \"50%\",\n    width: \"1rem\",\n    height: \"1rem\",\n    marginTop: \"100%\",\n    padding: \"0.1rem\",\n    paddingLeft: \"0px\",\n    marginLeft: \"0px\",\n    background: \"#DC143C\",\n    color: \"white\",\n    textAlign: \"center\",\n    font: \"0.7rem Arial, sans-serif\"\n  } */\n\n  const {videos} = useContext(RecordContext);\n  //Use state re-renders this component which is our Nav bar only :)\n  const [streamRef, setStreamStatus] = useState(false);\n\n  function changeStreamStatus(streamCheck) {\n    setStreamStatus(streamCheck)\n  }\n  return (\n\n    <HashRouter basename = \"/\">\n        <RecordProvider>\n        <div>\n          <nav class=\"navbar navbar-expand-sm fixed-bottom navbar-info bg-dark border border-white\" data-toggle=\"affix\">\n                  <div class=\"d-flex flex-row justify-content-md-center\" style={{width:\"100%\", display:\"flex\", justifyContent:\"center\"}}>\n                      <Link class=\"nav-link text-white\" style={{label:{flexDirection: \"column\"}}} to=\"/\"><PersonalVideoIcon fontSize=\"large\"/> Camera</Link>\n                      {!streamRef && <Link class=\"nav-link text-white\" style={{label:{flexDirection: \"column\"}}} to=\"/detectedRecords\"><SlideshowIcon fontSize=\"large\" style={{marginRight: \"0px\"}}/> Records</Link>}\n                  </div>\n          </nav>\n          <Switch>\n          <Route\n              exact path='/'\n              render={(props) => (\n              <Home {...props} changeStreamStatus={changeStreamStatus} />\n            )}\n          />\n              <Route exact path='/detectedRecords' component={Recordings}/>\n          </Switch>\n        </div>\n        </RecordProvider>\n    </HashRouter>\n\n  );\n};\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}